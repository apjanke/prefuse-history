package prefuse.util;

import java.util.ArrayList;
import java.util.List;

import prefuse.data.Edge;
import prefuse.data.Graph;
import prefuse.data.Node;
import prefuse.data.Schema;
import prefuse.data.Tree;
import prefuse.data.tuple.TableEdge;
import prefuse.data.tuple.TableNode;
import prefuse.data.tuple.TableTuple;

/**
 * Library routines for creating various Graph structures. All Graphs
 * generated by methods of this class include a String-valued
 * "label" field.
 *
 * @author <a href="http://jheer.org">jeffrey heer</a>
 */
public class GraphLib {

    private GraphLib() {
        // prevent instantiation
    }

    // ------------------------------------------------------------------------
    // Graph Creation Routines

    /**
     * Builds a completely unconnected (edge-free) graph with the given
     * number of nodes
     * @param n the number of nodes
     * @return a graph with n nodes and no edges
     */
    public static Graph<TableTuple<?>,TableNode,TableEdge> getNodes(int n) {
        Graph<TableTuple<?>,TableNode,TableEdge> g = Graph.createGraph();
        g.getNodeTable().addColumns(LABEL_SCHEMA);

        for ( int i=0; i < n; i++ ) {
            TableNode node = g.addNode();
            node.setString(LABEL, String.valueOf(i));
        }
        return g;
    }

    /**
     * Builds a "star" graph with one central hub connected to the given
     * number of satellite nodes.
     * @param n the number of points of the star
     * @return a "star" graph with n points, for a total of n+1 nodes
     */
    public static Graph<TableTuple<?>,TableNode,TableEdge> getStar(int n) {
        Graph<TableTuple<?>,TableNode,TableEdge> g = Graph.createGraph();

        g.getNodeTable().addColumns(LABEL_SCHEMA);
        g.getEdgeTable().addColumns(LABEL_SCHEMA);

        TableNode r = g.addNode();
        r.setString(LABEL, "0");

        for ( int i=1; i <= n; ++i ) {
            TableNode nn = g.addNode();
            nn.setString(LABEL, String.valueOf(i));
            TableEdge e = g.addEdge(r, nn);
            e.setString(LABEL, "0-" + nn );
        }
        return g;
    }

    /**
     * Returns a clique of given size. A clique is a graph in which every node
     * is a neighbor of every other node.
     * @param n the number of nodes in the graph
     * @return a clique of size n
     */
    public static Graph<TableTuple<?>,TableNode,TableEdge> getClique(int n) {
        Graph<TableTuple<?>,TableNode,TableEdge> g = Graph.createGraph();
        g.getNodeTable().addColumns(LABEL_SCHEMA);
        g.getEdgeTable().addColumns(LABEL_SCHEMA);

        TableNode nodes[] = new TableNode[n];
        for ( int i = 0; i < n; ++i ) {
            nodes[i] = g.addNode();
            nodes[i].setString(LABEL, String.valueOf(i));
        }
        for ( int i = 0; i < n; ++i ) {
            for ( int j = i; j < n; ++j ) {
				if ( i != j ) {
                    TableEdge e = g.addEdge(nodes[i], nodes[j]);
                    e.setString(LABEL, i + "-" + j);
                }
			}
        }
        return g;
    }

    /**
     * Returns a graph structured as an m-by-n grid.
     * @param m the number of rows of the grid
     * @param n the number of columns of the grid
     * @return an m-by-n grid structured graph
     */
    public static Graph<TableTuple<?>,TableNode,TableEdge> getGrid(int m, int n) {
        Graph<TableTuple<?>,TableNode,TableEdge> g = Graph.createGraph();
        g.getNodeTable().addColumns(LABEL_SCHEMA);
        g.getEdgeTable().addColumns(LABEL_SCHEMA);

        TableNode[] nodes = new TableNode[m*n];
        for ( int i = 0; i < m*n; ++i ) {
            nodes[i] = g.addNode();
            nodes[i].setString(LABEL, String.valueOf(i));

            if ( i >= n ) {
                TableEdge e = g.addEdge(nodes[i-n], nodes[i]);
                e.setString(LABEL, i-n + "-" + i);
            }
            if ( i % n != 0 ) {
                TableEdge e = g.addEdge(nodes[i-1], nodes[i]);
                e.setString(LABEL, i-1 + "-" + i);
            }
        }
        return g;
    }

    public static Graph<TableTuple<?>,TableNode,TableEdge> getHoneycomb(int levels) {
        Graph<TableTuple<?>,TableNode,TableEdge> g = Graph.createGraph();
        g.getNodeTable().addColumns(LABEL_SCHEMA);
        g.getEdgeTable().addColumns(LABEL_SCHEMA);
        List<TableNode> layer1 = halfcomb(g, levels);
        List<TableNode> layer2 = halfcomb(g, levels);
        for ( int i=0; i<levels<<1; ++i ) {
            TableNode n1 = layer1.get(i);
            TableNode n2 = layer2.get(i);
            TableEdge e = g.addEdge(n1, n2);
            e.setString(LABEL, n1.getString(LABEL) + "-" + n2.getString(LABEL));
        }
        return g;
    }

    private static <N extends Node<N,E>,E extends Edge<N,E>> List<N> halfcomb(Graph<?,N,E> g, int levels) {
        List<N> top   = new ArrayList<N>();
        List<N> layer = new ArrayList<N>();

        int label = 0;

        for ( int i=0; i<levels; ++i ) {
            N n = g.addNode();
            n.setString(LABEL, String.valueOf(label++));
            top.add(n);
        }
        for ( int i=0; i<levels; ++i ) {
            N n = null;
            for ( int j=0; j<top.size(); ++j ) {
                N p = top.get(j);
                if ( n == null ) {
                    n = g.addNode();
                    n.setString(LABEL, String.valueOf(label++));
                    layer.add(n);
                }
                Edge<N,E> e = g.addEdge(p, n);
                e.setString(LABEL, p.getString(LABEL) + "-" + n.getString(LABEL));
                n = g.addNode();
                n.setString(LABEL, String.valueOf(label++));
                layer.add(n);
                e = g.addEdge(p, n);
                e.setString(LABEL, p.getString(LABEL) + "-" + n.getString(LABEL));
            }
            if ( i == levels-1 ) {
                return layer;
            }
            top.clear();
            for ( int j=0; j<layer.size(); ++j ) {
                N p = layer.get(j);
                n = g.addNode();
                n.setString(LABEL, String.valueOf(label++));
                top.add(n);
                Edge<N,E> e = g.addEdge(p, n);
                e.setString(LABEL, p.getString(LABEL) + "-" + n.getString(LABEL));
            }
            layer.clear();
        }
        // should never happen
        return top;
    }

    /**
     * Returns a balanced tree of the requested breadth and depth.
     * @param breadth the breadth of each level of the tree
     * @param depth the depth of the tree
     * @return a balanced tree
     */
    public static Tree<TableTuple<?>,TableNode,TableEdge> getBalancedTree(int breadth, int depth) {
        Tree<TableTuple<?>,TableNode,TableEdge> t = Tree.createTree();
        t.getNodeTable().addColumns(LABEL_SCHEMA);

        TableNode r = t.addRoot();
        r.setString(LABEL, "0,0");

        if ( depth > 0 ) {
			balancedHelper(t, r, breadth, depth-1);
		}
        return t;
    }

    private static <N extends Node<N,?>> void balancedHelper(Tree<?,N,?> t, N n,
            int breadth, int depth)
    {
        for ( int i=0; i<breadth; ++i ) {
            N c = t.addChild(n);
            c.setString(LABEL, i+","+c.getDepth());
            if ( depth > 0 ) {
				balancedHelper(t,c,breadth,depth-1);
			}
        }
    }

    /**
     * Returns a left deep binary tree
     * @param depth the depth of the tree
     * @return the generated tree
     */
    public static Tree<TableTuple<?>,TableNode,TableEdge> getLeftDeepTree(int depth) {
        Tree<TableTuple<?>,TableNode,TableEdge> t = Tree.createTree();

        t.getNodeTable().addColumns(LABEL_SCHEMA);

        TableNode r = t.addRoot();
        r.setString(LABEL, "0,0");

        deepHelper(t, r, 2, depth, true);
        return t;
    }

    /**
     * Returns a right deep binary tree
     * @param depth the depth of the tree
     * @return the generated Tree
     */
    public static Tree<TableTuple<?>,TableNode,TableEdge> getRightDeepTree(int depth) {
        Tree<TableTuple<?>,TableNode,TableEdge> t = Tree.createTree();

        t.getNodeTable().addColumns(LABEL_SCHEMA);

        TableNode r = t.addRoot();
        r.setString(LABEL, "0,0");

        deepHelper(t, r, 2, depth, false);
        return t;
    }

    /**
     * Create a diamond tree, with a given branching factor at
     * each level, and depth levels for the two main branches.
     * @param b the number of children of each branch node
     * @param d1 the length of the first (left) branch
     * @param d2 the length of the second (right) branch
     * @return the generated Tree
     */
    public static Tree<TableTuple<?>,TableNode,TableEdge> getDiamondTree(int b, int d1, int d2) {
        Tree<TableTuple<?>,TableNode,TableEdge> t = Tree.createTree();

        t.getNodeTable().addColumns(LABEL_SCHEMA);

        TableNode r = t.addRoot();
        r.setString(LABEL, "0,0");

        TableNode left = t.addChild(r);
        left.setString(LABEL, "1,0");
        TableNode right = t.addChild(r);
        right.setString(LABEL, "1,1");

        deepHelper(t, left, b, d1-2, true);
        deepHelper(t, right, b, d1-2, false);

        List<TableNode> children = left.children();
        while ( !children.isEmpty()) {
			left = children.get(0);
			children = left.children();
		}
        children = right.children();
        while ( !children.isEmpty()) {
			right = children.get(children.size() - 1);
			children = right.children();
		}

        deepHelper(t, left, b, d2-1, false);
        deepHelper(t, right, b, d2-1, true);

        return t;
    }

    private static <N extends Node<N,?>> void deepHelper(Tree<?,N,?> t, N n,
            int breadth, int depth, boolean left)
    {
        N c = t.addChild(n);
        c.setString(LABEL, "0,"+c.getDepth());
        if ( left && depth > 0 ) {
			deepHelper(t, c, breadth, depth-1, left);
		}

        for ( int i=1; i<breadth; ++i ) {
            c = t.addChild(n);
            c.setString(LABEL, i+","+c.getDepth());
        }
        if ( !left && depth > 0 ) {
			deepHelper(t, c, breadth, depth-1, left);
		}
    }


    // ------------------------------------------------------------------------

    /** Label data field included in generated Graphs */
    public static final String LABEL = "label";
    /** Node table schema used for generated Graphs */
    public static final Schema LABEL_SCHEMA = new Schema();
    static {
        LABEL_SCHEMA.addColumn(LABEL, String.class, "");
    }

} // end of class GraphLib
